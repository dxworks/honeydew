{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Honeydew","text":"<p>Honeydew is a tool that extracts facts from C# or Visual Basic Solution or Project</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>Honeydew extract &lt;input_path&gt;</code> - Extract facts. For more information, visit Extract Command</li> <li><code>Honeydew load &lt;path_to_json_model&gt;</code> - Load Model from JSON File. For more information, visit Load Command</li> </ul>"},{"location":"#docker","title":"Docker","text":"<p>Honeydew can be run from a Docker container like this:</p>"},{"location":"#linux-macos","title":"Linux / MacOs","text":"<pre><code>docker run --rm -it -v $(pwd)/results:/app/results -v $(pwd)/&lt;input&gt;:&lt;input&gt; dxworks/honeydew extract &lt;input&gt; -p\n</code></pre>"},{"location":"#powershell","title":"Powershell","text":"<pre><code>docker run --rm -it -v ${PWD}/results:/app/results -v ${PWD}/&lt;input&gt;:&lt;input&gt; dxworks/honeydew extract &lt;input&gt; -p\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#download","title":"Download","text":"<p>The Binaries and source code can be downloaded from Honeydew Releases from GitHub</p>"},{"location":"installation/#build-project-source-code","title":"Build Project Source Code","text":""},{"location":"installation/#self-contained-application-single-file-app","title":"Self-contained application - Single-file app","text":""},{"location":"installation/#for-windows-64-bit","title":"For Windows 64-bit","text":"<pre><code>dotnet publish -r win-x64 --self-contained true -p:PublishSingleFile=true \n</code></pre>"},{"location":"installation/#for-linux-64-bit","title":"For Linux 64-bit","text":"<pre><code>dotnet publish -r linux-x64 --self-contained true -p:PublishSingleFile=true \n</code></pre>"},{"location":"installation/#for-macos-64-bit","title":"For macOs 64-bit","text":"<pre><code>dotnet publish -r osx-x64 --self-contained true -p:PublishSingleFile=true \n</code></pre>"},{"location":"installation/#self-contained-application","title":"Self-contained application","text":""},{"location":"installation/#for-windows-64-bit_1","title":"For Windows 64-bit","text":"<pre><code>dotnet publish -r win-x64\n</code></pre>"},{"location":"installation/#for-linux-64-bit_1","title":"For Linux 64-bit","text":"<pre><code>dotnet publish -r linux-x64\n</code></pre>"},{"location":"installation/#for-macos-64-bit_1","title":"For macOs 64-bit","text":"<pre><code>dotnet publish -r osx-x64\n</code></pre>"},{"location":"commands/adapt/","title":"Adapt","text":"<p>This command is used to adapt a raw model file from version 2.1.x to version 3.x.x. It will create a new file in the results folder with the raw model adapted to the new version.</p> <pre><code>.\\Honeydew adapt &lt;input_path&gt;\n</code></pre>"},{"location":"commands/adapt/#example","title":"Example","text":"<pre><code>Honeydew adapt \"input_folder\"\n</code></pre>"},{"location":"commands/extract/","title":"Extract","text":"<p>For extracting information about a solution or project use the following command:</p> <pre><code>Honeydew extract &lt;input_path&gt; [-n|--project-name &lt;name&gt;] [--no-progress-bars] [--no-trim-paths] [-p|--parallel]\n</code></pre> <p>If <code>input_path</code> is a path to a solution file (.sln), Honeydew will extract facts from that solution file</p> <p>If <code>input_path</code> is a path to a project file (.csproj or .vbproj), Honeydew will extract facts from that project</p> <p>If <code>input_path</code> is a path to a folder, Honeydew will find all the solution files and project files and extract facts from those</p> <p>The output files will be placed in a folder named <code>results</code></p>"},{"location":"commands/extract/#options","title":"Options","text":"<ul> <li><code>-n</code> or <code>--project-name</code></li> </ul> <p>The flag must be followed by a string. This flag is used to set the project name. If not present, the project name   will be deduced from the <code>&lt;input_path&gt;</code>. The project name is used to name the output files</p> <ul> <li><code>--no-progress-bars</code></li> </ul> <p>If present, then all the messages will be printed in the console. Otherwise, output will contain progress bars for a   better visualisation of the progress</p> <ul> <li><code>--no-trim-paths</code></li> </ul> <p>If present, Honeydew will not trim the File Paths present in the created model</p> <ul> <li><code>-p</code> or <code>--parallel</code></li> </ul> <p>If present, Honeydew will make the extraction in parallel where possible</p>"},{"location":"commands/extract/#example","title":"Example","text":""},{"location":"commands/extract/#sequential-extraction","title":"Sequential Extraction","text":"<pre><code>Honeydew extract \"input_folder\"\n</code></pre>"},{"location":"commands/extract/#parallel-extraction","title":"Parallel Extraction","text":"<pre><code>Honeydew extract \"input_folder\" -p\n</code></pre>"},{"location":"commands/load/","title":"Load","text":"<p>For loading a model from a json file</p> <pre><code>Honeydew load &lt;path_to_json_model&gt; [-n|--project-name &lt;name&gt;] [--no-progress-bars] [-p|--parallel]\n</code></pre>"},{"location":"commands/load/#options","title":"Options","text":"<ul> <li><code>-n</code> or <code>--project-name</code></li> </ul> <p>The flag must be followed by a string. This flag is used to set the project name. If not present, the project name   will be deduced from the <code>&lt;path_to_json_model&gt;</code>. The project name is used to name the output files</p> <ul> <li><code>--no-progress-bars</code></li> </ul> <p>If present, then all the messages will be printed in the console. Otherwise, output will contain progress bars for a   better visualisation of the progress</p> <ul> <li><code>-p</code> or <code>--parallel</code></li> </ul> <p>If present, Honeydew will run scripts in parallel where possible</p>"},{"location":"commands/load/#example","title":"Example","text":"<pre><code>Honeydew load \"model.json\"\n</code></pre>"},{"location":"model/extractor/","title":"Extractor","text":""},{"location":"model/extractor/#hierarchy","title":"Hierarchy","text":"<p>Below are presented the main Visitors</p> classDiagram ITypeVisitor  &lt;|-- ICompositeVisitor ITypeVisitor  &lt;|-- IExtractionVisitor ITypeVisitor  &lt;|-- IRequireCSharpExtractionHelperMethodsVisitor  ICompositeVisitor  &lt;|.. CompositeVisitor  class ITypeVisitor{     Accept(IVisitor visitor) } class IExtractionVisitor{     Visit(TSyntaxNode syntaxNode, TModelType modelType) TModelType         } class ICompositeVisitor{     Add(ITypeVisitor visitor)     GetContainedVisitors() IEnumerable~ITypeVisitor~ } class IRequireCSharpExtractionHelperMethodsVisitor{     CSharpExtractionHelperMethods CSharpHelperMethods }  <p>There are visitors for each type of the model</p> <ul> <li>ICompilationUnitVisitor</li> <li>IClassVisitor</li> <li>IDelegateVisitor</li> <li>IMethodVisitor</li> <li>IConstructorVisitor</li> <li>IFieldVisitor</li> <li>IPropertyVisitor</li> <li>IAttributeVisitor</li> <li>ILocalFunctionVisitor</li> <li>IMethodSignatureVisitor</li> </ul>"},{"location":"model/extractor/#add-functionality-to-itypevisitors","title":"Add Functionality To ITypeVisitors","text":"<p>To add functionality to certain extraction visitors, one can declare custom visitors that extend <code>IVisitor</code></p> <p>For Example:</p> <p><code>IRequireCSharpExtractionHelperMethodsVisitor</code> defines some helper methods to be used by the extraction visitors. <code>ExtractionModelsSetterVisitor</code> is used to set those helper functions to all.</p> classDiagram IVisitor &lt;|.. ExtractionModelsSetterVisitor  class IVisitor{         Visit(ITypeVisitor visitor) } class ExtractionModelsSetterVisitor{     -ExtractionModelsSetterVisitor  _extractionHelperMethods }"},{"location":"model/extractor/#defining-custom-extraction-visitor-example","title":"Defining Custom Extraction Visitor Example","text":"<p>Lets say we extract the name and parameters of Attributes of C# classes.</p>"},{"location":"model/extractor/#model-definition","title":"Model Definition","text":"<p>First of all, we define the model that will store the relevant data of the attribute.</p> <pre><code>public class AttributeType\n{\n    public string Name { get; set; }\n\n    public string Target { get; set; }    \n}\n</code></pre>"},{"location":"model/extractor/#extraction-visitor","title":"Extraction Visitor","text":""},{"location":"model/extractor/#interface","title":"Interface","text":"<p>Next, we define the extraction visitor's interface. To simplify the extraction and join of the attribute data, the extraction visitor should extend the generic interface <code>IExtractionVisitor</code>.</p> <p>The first parameter is the syntax element from which we want to extract data and the second parameter is our model that holds only the relevant data.</p> <pre><code>public interface ICSharpAttributeVisitor : IExtractionVisitor&lt;AttributeSyntax, AttributeType&gt;\n{\n}\n</code></pre>"},{"location":"model/extractor/#implementation","title":"Implementation","text":"<p>After the extraction visitor interface is done, we can move on to its implementation</p> <p>To have access certain helper methods, <code>AttributeInfoVisitor</code> can implement <code>IRequireCSharpExtractionHelperMethodsVisitor</code></p> <pre><code>public class AttributeInfoVisitor : ICSharpAttributeVisitor, IRequireCSharpExtractionHelperMethodsVisitor\n{\n    public CSharpExtractionHelperMethods CSharpHelperMethods { get; set; }\n\n    public IAttributeType Visit(AttributeSyntax attributeSyntax, AttributeType attributeType)\n    {\n        // todo populate here the 'attributeType' with data from 'attributeSyntax' \n\n        return attributeType;\n    }\n}\n</code></pre> <p>Note: Normally, the class <code>AttributeInfoVisitor</code> must implement <code>void Accept(IVisitor visitor)</code> method, but it's not relevant for this example. It can be left empty.</p>"},{"location":"model/extractor/#adding-to-attribute-data-to-class-model","title":"Adding To Attribute data to Class Model","text":"<p>We now have the possibility to extract data from attributes, but we need that info to be added to the class model</p> <p>We define a class-type Visitor that will contain will execute the previously defined visitor for all its attributes</p> <pre><code>public class AttributeSetterClassVisitor : CompositeVisitor, ICSharpClassVisitor\n{\n    public AttributeSetterClassVisitor(IEnumerable&lt;ICSharpAttributeVisitor&gt; visitors) : base(visitors)\n    {\n    }\n\n    public IClassType Visit(BaseTypeDeclarationSyntax syntaxNode, IClassType classType)\n    {\n        foreach (var attributeSyntax in syntaxNode.DescendantNodes().OfType&lt;AttributeSyntax&gt;())\n        {\n            AttributeType attributeModel = new AttributeType();\n\n            foreach (var visitor in GetContainedVisitors())\n            {\n                if (visitor is ICSharpAttributeVisitor extractionVisitor)\n                {\n                    attributeModel = extractionVisitor.Visit(attributeSyntax, attributeModel);\n                }\n            }\n\n            classType.Attributes.Add(attributeModel);\n        }\n\n        return classType;\n    }\n}\n</code></pre> <p>Let's break it down:</p> <ol> <li><code>AttributeSetterClassVisitor</code> extends <code>CompositeVisitor</code> because we might want to run multiple attribute-type visitors for the class' attributes </li> <li><code>AttributeSetterClassVisitor</code> implements the <code>ICSharpClassVisitor</code> interface because <code>AttributeSetterClassVisitor</code> should be visitor that runs for each class of the project</li> <li>With the help of the constructor, we can accept only visitors that run on C# classes</li> <li>In the <code>Visit</code> method, we iterate through all the attributes of the class and run all the visitors that we received in the constructors</li> <li>After the attribute model is populated with data from the visitor, it will be added to the attribute list </li> </ol>"},{"location":"model/extractor/#use-the-custom-extraction-visitor","title":"Use the custom Extraction Visitor","text":"<p>Finally, we can add our visitor to the rest of the extraction visitors that run for each file of a C# project</p> <pre><code>var compositeVisitor = new CompositeVisitor();\n\ncompositeVisitor.Add(new ClassSetterCompilationUnitVisitor(new List&lt;ICSharpClassVisitor&gt;\n{\n    new BaseInfoClassVisitor(),\n    new AttributeSetterClassVisitor(new List&lt;IAttributeVisitor&gt;\n    {\n        new AttributeInfoVisitor()\n    })\n}));\n\nvar factExtractor = new CSharpFactExtractor(new CSharpSyntacticModelCreator(),\n    new CSharpSemanticModelCreator(new CSharpCompilationMaker()), compositeVisitor);\n</code></pre>"},{"location":"model/types/","title":"Types","text":""},{"location":"model/types/#entire-hierarchy","title":"Entire Hierarchy","text":"classDiagram  IType  &lt;|-- IBaseType IType  &lt;|-- INamedType IType  &lt;|-- ITypeWithAttributes IType  &lt;|-- ITypeWithCyclomaticComplexity IType  &lt;|-- ITypeWithLinesOfCode IType  &lt;|-- ITypeWithLocalFunctions IType  &lt;|-- ITypeWithMetrics IType  &lt;|-- ITypeWithModifiers  INamedType &lt;|-- IImportType INamedType &lt;|-- IEntityType INamedType &lt;|-- IContainedType  IContainedType &lt;|-- ICallingMethodsType IContainedType &lt;|-- IClassType IContainedType &lt;|-- IFieldType IContainedType &lt;|-- IMethodSignatureType  ICallingMethodsType &lt;|-- IMethodSkeletonType ICallingMethodsType &lt;|-- IPropertyType  IMethodSkeletonType &lt;|-- IMethodType IMethodSkeletonType &lt;|-- IConstructorType  IMethodType &lt;|-- IMethodTypeWithLocalFunctions  IClassType &lt;|-- IDelegateType IClassType &lt;|-- IMembersClassType  IMembersClassType &lt;|-- IPropertyMembersClassType  IFieldType &lt;|-- IPropertyType  IMethodSignatureType &lt;|-- IDelegateType IMethodSignatureType &lt;|-- IMethodSkeletonType  ITypeWithAttributes &lt;|-- IClassType ITypeWithAttributes &lt;|-- IFieldType ITypeWithAttributes &lt;|-- IMethodSkeletonType ITypeWithAttributes &lt;|-- IParameterType ITypeWithAttributes &lt;|-- IReturnValueType  ITypeWithCyclomaticComplexity &lt;|-- IMethodSkeletonType ITypeWithCyclomaticComplexity &lt;|-- IPropertyType  ITypeWithLinesOfCode &lt;|-- ICompilationUnitType ITypeWithLinesOfCode &lt;|-- IMembersClassType ITypeWithLinesOfCode &lt;|-- IMethodSkeletonType ITypeWithLinesOfCode &lt;|-- IPropertyType  ITypeWithLocalFunctions &lt;|-- IMethodTypeWithLocalFunctions  ITypeWithMetrics &lt;|-- IClassType ITypeWithMetrics &lt;|-- ICompilationUnitType ITypeWithMetrics &lt;|-- IFieldType ITypeWithMetrics &lt;|-- IMethodSkeletonType  ITypeWithModifiers &lt;|-- IClassType ITypeWithModifiers &lt;|-- IFieldType ITypeWithModifiers &lt;|-- IMethodSkeletonType  class IBaseType{         +IEntityType Type     +string Kind } class INamedType{     +string Name } class IImportType{   +string Alias   +string AliasType } class IEntityType{   +IList~GenericType~ ContainedTypes      } class IContainedType{       +string ContainingTypeName      } class ICallingMethodsType{       +IList~IMethodSignatureType~ CalledMethods      } class IClassType{      +string ClassType          +string FilePath          +IList~IBaseTypes~ BaseTypes          +IList~IImportType~ Imports      } class IFieldType{      +IEntityType Type     +bool IsEvent      } class IMethodSignatureType{     +IList~IParameterType~ ParameterTypes      } class IMethodType{    +IReturnValueType ReturnValue } class IMethodTypeWithLocalFunctions{    +IReturnValueType ReturnValue } class IDelegateType{     +IReturnValueType ReturnValue } class IMembersClassType{     +IList~IFieldType~ Fields     +IList~IConstructorType~ Constructors     +IList~IMethodType~ Methods } class IPropertyMembersClassType{     +IList~IPropertyType~ Properties } class ITypeWithAttributes{     +IList~IAttributeType~ Attributes } class IParameterType{     +IEntityType Type } class IReturnValueType{     +IEntityType Type } class ITypeWithCyclomaticComplexity{     +int CyclomaticComplexity } class ITypeWithLinesOfCode{     +LinesOfCode Loc } class ICompilationUnitType{     +IList~IClassType~ ClassTypes     +string FilePath     +IList~IImportType~ Imports } class ITypeWithLocalFunctions{     +IList~IMethodTypeWithLocalFunctions~ LocalFunctions } class ITypeWithMetrics{     +IList~MetricModel~ Metrics } class ITypeWithModifiers{             +string AccessModifier     +string Modifier }"},{"location":"model_results/other/","title":"Other Results","text":""},{"location":"model_results/other/#statistics-result","title":"Statistics Result","text":"<p>Offers a high-level view of the repository structure</p> <pre><code>interface Statistics \n{\n    Version: string;\n    Projects: number;\n    Solutions: number;\n    Files: number;\n    Classes: number;\n    Delegates: number;\n    Interfaces: number;\n    Enums: number;\n    SourceCodeLines: number;\n}\n</code></pre>"},{"location":"model_results/other/#cyclomatic-complexity-results","title":"Cyclomatic Complexity Results","text":"<pre><code>interface CycloResult\n{\n    file: File\n}\n\ninterface File \n{\n    concerns: Concern[]\n}\n\ninterface Concern\n{\n    entity: string;\n    tag: string;\n    strength: number;\n}\n</code></pre>"},{"location":"model_results/raw/","title":"Raw Model","text":""},{"location":"model_results/raw/#description","title":"Description","text":"<p>This is the raw model that is exported by the extract command and is based on the interfaces described in the Model Section</p>"},{"location":"model_results/raw/#entities","title":"Entities","text":""},{"location":"model_results/raw/#repository","title":"Repository","text":"<pre><code>interface Repository\n{\n  Version: string;\n  Solutions: SolutionModel[];\n  Projects: ProjectModel[]\n}\n</code></pre>"},{"location":"model_results/raw/#solution","title":"Solution","text":"<pre><code>interface Solution\n{\n    FilePath: string;\n    ProjectsPaths: string[];\n    Metadata: Dictionary&lt;string, Dictionary&lt;string, string&gt;&gt;\n}\n</code></pre>"},{"location":"model_results/raw/#project","title":"Project","text":"<p><pre><code>interface ProjectModel\n{\n    Language: string;\n    Name: string;\n    FilePath: string;\n    ProjectReferences: string[];\n    Namespaces: NamespaceModel[];\n    CompilationUnits: ICompilationUnitType[];\n    Metadata: Dictionary&lt;string, Dictionary&lt;string, string&gt;&gt;\n}\n</code></pre> Language can be either: <code>C#</code> or <code>Visual Basic</code></p>"},{"location":"model_results/raw/#namespace","title":"Namespace","text":"<pre><code>interface NamespaceModel \n{\n    Name: string;\n    ClassNames: string[];\n}\n</code></pre>"},{"location":"model_results/raw/#compilation-unit","title":"Compilation Unit","text":"<p>Up until now, the presented models were common to all programming languages. Starting from the compilation unit type, all the interface types are implemented in a dedicated project for each programming language. By doing so, the extractors can keep the same interface across the model, yet still be able to store the particular features of each programming language.</p> C# <pre><code>interface CompilationUnitType\n{\n    FilePath: string;\n    ClassTypes: IClassType[];\n    Imports: IImportType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre> Visual Basic <pre><code>interface CompilationUnitType\n{\n    FilePath: string;\n    ClassTypes: IClassType[];\n    Imports: IImportType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre>"},{"location":"model_results/raw/#class","title":"Class","text":"C# <pre><code>interface ClassModel \n{\n    ClassType: string;\n    Mame: string;\n    GenericParameters: IGenericParameterType[];\n    FilePath: string;\n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    Imports: IImportType[];\n    Fields: FieldType[];\n    Properties: PropertyType[];\n    Constructors: IConstructorType[];\n    Methods: IMethodType[];\n    Destructor?: IDestructorType;\n    Attributes: IAttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> Visual Basic <pre><code>interface ClassModel \n{\n    ClassType: string;\n    Name: string;\n    GenericParameters: IGenericParameterType[];\n    FilePath: string; \n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingModuleName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    Imports: IImportType[]; \n    Fields: FieldType[];\n    Properties: PropertyType[];\n    Constructors: ConstructorType[];\n    Methods: MethodType[]; \n    Destructor?: IDestructorType;\n    Attributes: AttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> <p>ClassType can be either: <code>class</code>, <code>interface</code> or <code>struct</code></p>"},{"location":"model_results/raw/#enum","title":"Enum","text":"C# <pre><code>interface EnumModel\n{\n    ClassType: string;\n    Mame: string;\n    FilePath: string;\n    Type: string;\n    Labels: IEnumLabelType[];\n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    Imports: IImportType[]; \n    Attributes: IAttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> Visual Basic <pre><code>interface EnumModel \n{\n    ClassType: string;\n    Mame: string;\n    FilePath: string;\n    Type: string;\n    Labels: IEnumLabelType[];\n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingModuleName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    Imports: IImportType[]; \n    Attributes: IAttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> <p>ClassType is <code>enum</code></p>"},{"location":"model_results/raw/#enum-label","title":"Enum Label","text":"C# <pre><code>interface EnumLabel \n{\n    Name: string; \n    Attributes: IAttributeType[]; \n}\n</code></pre> Visual Basic <pre><code>interface EnumLabel\n{\n    Name: string; \n    Attributes: IAttributeType[]; \n}\n</code></pre>"},{"location":"model_results/raw/#delegate","title":"Delegate","text":"C# <pre><code>interface DelegateModel \n{\n    ClassType: string;\n    Mame: string;\n    FilePath: string;\n    GenericParameters: IGenericParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    ParameterTypes: IParameterType[];\n    ReturnValue: IReturnValueType;\n    Imports: IImportType[]; \n    Attributes: IAttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> Visual Basic <pre><code>interface DelegateModel \n{\n    ClassType: string;\n    Mame: string;\n    FilePath: string;\n    GenericParameters: IGenericParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    ContainingNamespaceName: string;\n    ContainingModuleName: string;\n    ContainingClassName: string;\n    BaseTypes: IBaseType[];\n    ParameterTypes: IParameterType[];\n    ReturnValue: IReturnValueType;\n    Imports: IImportType[]; \n    Attributes: IAttributeType[];\n    Metrics: MetricModel[];\n    Loc: LinesOfCode;\n}\n</code></pre> <p>ClassType is <code>delegate</code></p>"},{"location":"model_results/raw/#import","title":"Import","text":"C# <pre><code>interface Import \n{\n    Name: string; \n    IsStatic: bool;\n    Alias: string;\n    AliasType: string;\n}\n</code></pre> Visual Basic <pre><code>interface Import \n{\n    Name: string; \n    IsStatic: bool;\n    Alias: string;\n    AliasType: string;\n}\n</code></pre> <p>AliasType can have one of the following values: - None - Namespace - Class - NotDetermined</p>"},{"location":"model_results/raw/#base-type","title":"Base Type","text":"C# <pre><code>interface BaseType \n{\n    Type: IEntityType; \n    Kind: string; \n}\n</code></pre> Visual Basic <pre><code>interface BaseType \n{\n    Type: IEntityType; \n    Kind: string; \n}\n</code></pre> <p>Kind can be either: <code>class</code> or <code>interface</code></p>"},{"location":"model_results/raw/#entity-type","title":"Entity Type","text":"C# <pre><code>interface EntityType \n{\n    Name: string; \n    FullType: GenericType;\n    IsExtern: bool;\n}\n</code></pre> Visual Basic <pre><code>interface EntityType\n{\n    Name: string; \n    FullType: GenericType;\n    IsExtern: bool; \n}\n</code></pre>"},{"location":"model_results/raw/#generic-type","title":"Generic Type","text":"<pre><code>interface GenericType\n{\n    Name: string;\n    ContainedTypes: GenericType[];\n    IsNullable: bool;\n}\n</code></pre>"},{"location":"model_results/raw/#attribute","title":"Attribute","text":"C# <pre><code>interface Attribute \n{\n    Name: string; \n    Type: IEntityType;\n    ParameterTypes: IParameterTypes[];\n    Target: string;\n}\n</code></pre> Visual Basic <pre><code>interface Attribute \n{\n    Name: string; \n    Type: IEntityType;\n    ParameterTypes: IParameterTypes[];\n    Target: string;\n}\n</code></pre> <p>Target can be one of the following: - method - type - field - property - param - return</p>"},{"location":"model_results/raw/#field","title":"Field","text":"C# <pre><code>interface Field \n{\n    Name: string; \n    Type: IEntityType;\n    Modifier: string;\n    AccessModifier: string;\n    IsEvent: bool;\n    IsNullable: bool;\n    Attributes: IAttributeType[];\n    Metrics: MetricModel[]\n}\n</code></pre> Visual Basic <pre><code>interface Field \n{\n    Name: string; \n    Type: IEntityType;\n    Modifier: string;\n    AccessModifier: string;\n    IsNullable: bool;\n    Attributes: IAttributeType[];\n    Metrics: MetricModel[]\n}\n</code></pre>"},{"location":"model_results/raw/#property","title":"Property","text":"C# <pre><code>interface Property \n{\n    Name: string; \n    Type: IEntityType;\n    Modifier: string;\n    AccessModifier: string;\n    IsEvent: bool;\n    IsNullable: bool;\n    CyclomaticComplexity: number;\n    Accessors: IAccessorMethodType[];\n    Loc: LinesOfCode;\n    Attributes: IAttributeType[];\n    Metrics: MetricModel[]\n}\n</code></pre> Visual Basic <pre><code>interface Property \n{\n    Name: string; \n    Type: IEntityType;\n    Modifier: string;\n    AccessModifier: string;\n    IsNullable: bool;\n    CyclomaticComplexity: number;\n    Accessors: IAccessorMethodType[];\n    Loc: LinesOfCode;\n    Attributes: IAttributeType[];\n    Metrics: MetricModel[]\n}\n</code></pre>"},{"location":"model_results/raw/#accessor-method","title":"Accessor Method","text":"C# <pre><code>interface AccessorMethod \n{\n    Name: string;\n    ReturnValue: IReturnValueType;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre> Visual Basic <pre><code>interface AccessorMethod \n{\n    Name: string;\n    ReturnValue: IReturnValueType;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre>"},{"location":"model_results/raw/#method","title":"Method","text":"C# <pre><code>interface Method \n{\n    Name: string;\n    ReturnValue: IReturnValueType;\n    ParameterTypes: IParameterType[];\n    GenericParameters: IGenericParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre> Visual Basic <pre><code>interface Method \n{\n    Name: string;\n    ReturnValue: IReturnValueType;\n    ParameterTypes: IParameterType[];\n    GenericParameters: IGenericParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre>"},{"location":"model_results/raw/#constructor","title":"Constructor","text":"C# <pre><code>interface Constructor \n{\n    Name: string;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre> Visual Basic <pre><code>interface Constructor \n{\n    Name: string;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre>"},{"location":"model_results/raw/#destructor","title":"Destructor","text":"C# <pre><code>interface Destructor \n{\n    Name: string;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre> Visual Basic <pre><code>interface Destructor \n{\n    Name: string;\n    ParameterTypes: IParameterType[];\n    AccessModifier: string;\n    Modifier: string;\n    Attributes: IAttributeType[];\n    CalledMethods: IMethodCallType[];\n    AccessedFields: AccessField[];\n    CyclomaticComplexity: number;\n    LocalVariableTypes: ILocalVariableType[];\n    LocalFunctions: IMethodType[];\n    Loc: LinesOfCode;\n    Metrics: MetricModel[];\n}\n</code></pre>"},{"location":"model_results/raw/#parameter","title":"Parameter","text":"C# <pre><code>interface Parameter \n{\n    Type: EntityType; \n    Modifier: string;\n    DefaultValue?: string;\n    IsNullable: bool;\n    Attributes: IAttributeType[];\n}\n</code></pre> Visual Basic <pre><code>interface Parameter \n{\n    Type: EntityType; \n    Modifier: string;\n    DefaultValue?: string;\n    IsNullable: bool;\n    Attributes: IAttributeType[]; \n}\n</code></pre>"},{"location":"model_results/raw/#generic-parameter","title":"Generic Parameter","text":"C# <pre><code>interface GenericParameter \n{\n    Name: string;\n    Modifier: string;\n    Constraints: EntityType[];\n    Attributes: IAttributeType[];\n}\n</code></pre> Visual Basic <pre><code>interface GenericParameter \n{\n    Name: string;\n    Modifier: string;\n    Constraints: EntityType[];\n    Attributes: IAttributeType[];\n}\n</code></pre>"},{"location":"model_results/raw/#return-value","title":"Return Value","text":"C# <pre><code>interface ReturnValue\n{\n    Type: IEntityType;\n    Modifier: string;\n    IsNullable: bool;\n    Attributes: IAttributeType[];\n}\n</code></pre> Visual Basic <pre><code>interface ReturnValue \n{\n    Type: IEntityType;\n    Modifier: string;\n    IsNullable: bool;\n    Attributes: IAttributeType[];\n}\n</code></pre>"},{"location":"model_results/raw/#accessed-field","title":"Accessed Field","text":"<pre><code>interface AccessedField\n{\n    Name: string;\n    DefinitionClassName: string;\n    LocationClassName: string;\n    Kind: number;\n}\n</code></pre> <p>Kind can be either <code>0</code> (Getter) or <code>1</code> (Setter)</p> <p><code>DefinitionClassName</code> is used for the base class and <code>LocationClassName</code> is used for the derived class</p>"},{"location":"model_results/raw/#called-method","title":"Called Method","text":"C# <pre><code>interface MethodCall\n{\n    Name: string;\n    DefinitionClassName: string;\n    LocationClassName: string;\n    MethodDefinitionNames: string[];\n    GenericParameters: EntitTye[];\n    ParameterTypes: IParameterType[];\n}\n</code></pre> Visual Basic <pre><code>interface MethodCall\n{\n    Name: string;\n    DefinitionClassName: string;\n    LocationClassName: string;\n    MethodDefinitionNames: string[];\n    GenericParameters: EntitTye[];\n    ParameterTypes: IParameterType[];\n}\n</code></pre>"},{"location":"model_results/raw/#local-variable","title":"Local Variable","text":"C# <pre><code>interface LocalVariable\n{\n    Name: string;\n    Type: IEntityType;\n    Modifier: string;\n    IsNullable: bool;\n}\n</code></pre> Visual Basic <pre><code>interface LocalVariable\n{\n    Name: string;\n    Type: IEntityType;\n    Modifier: string;\n    IsNullable: bool;\n}\n</code></pre>"},{"location":"model_results/raw/#metric-model","title":"Metric Model","text":"<pre><code>interface MetricModel\n{\n    Name: string;\n    ExtractorName: string;\n    ValueType: string;\n    Value?: object;\n}\n</code></pre>"},{"location":"model_results/raw/#lines-of-code","title":"Lines of Code","text":"<pre><code>interface LinesOfCode\n{\n    SourceLines: number;\n    CommentedLines: number;\n    EmptyLines: number;\n}\n</code></pre>"},{"location":"model_results/relations/","title":"Relations between Entities","text":""},{"location":"model_results/relations/#class-relations","title":"Class Relations","text":""},{"location":"model_results/relations/#file-relations","title":"File Relations","text":""},{"location":"model_results/relations/#project-relations","title":"Project Relations","text":""},{"location":"model_results/relations/#solution-and-project-relations","title":"Solution and Project Relations","text":""},{"location":"model_results/spektrum/","title":"Spektrum","text":""},{"location":"model_results/spektrum/#description","title":"Description","text":"<p>Spektrum is a static, language-independent code analysis tool that generates test coverage metrics based on input generated from other external tools.</p> <p>Examples of method names and ids:</p> <p>Method Name: <code>Method1#string,int</code></p> <p>Method ID: <code>Class1.cs-&gt;Class1@Method1#double</code></p>"},{"location":"model_results/spektrum/#entities","title":"Entities","text":""},{"location":"model_results/spektrum/#repository","title":"Repository","text":"<pre><code>interface Repository \n{\n    solutions: Solution[];\n    projects: Project[];\n}\n</code></pre>"},{"location":"model_results/spektrum/#solution","title":"Solution","text":"<pre><code>interface Solution \n{\n    path: string;\n    projects: string[];\n}\n</code></pre>"},{"location":"model_results/spektrum/#project","title":"Project","text":"<pre><code>interface Project \n{\n    name: string;\n    path: string;\n    files: File[];\n    projectReferences: string[];\n    externalReferences: string[];\n}\n</code></pre>"},{"location":"model_results/spektrum/#file","title":"File","text":"<pre><code>interface File \n{\n    name: string;\n    path: string;\n    namespaces: Namespace[]\n}\n</code></pre>"},{"location":"model_results/spektrum/#namespace","title":"Namespace","text":"<pre><code>interface Namespace \n{\n    name: string;\n    classes: Class[]\n}\n</code></pre>"},{"location":"model_results/spektrum/#class","title":"Class","text":"<pre><code>interface Class \n{\n    name: string;\n    type: string;\n    usingStatements: string[];\n    attributes: string[];\n    usedClasses: stirng[];\n    methods: Method[];\n}\n</code></pre>"},{"location":"model_results/spektrum/#method","title":"Method","text":"<pre><code>interface Method \n{\n    name: string;\n    type: string;\n    attributes: string[];\n    modifiers: string[];\n    callers: string[];\n    calledMethods: string[]; \n}\n</code></pre>"},{"location":"scriptbee/integration/","title":"ScriptBee","text":""},{"location":"scriptbee/integration/#description","title":"Description","text":"<p>ScriptBee is a scripting module designed as the go-to service when analysis system in the DxWorks ecosystem.  It offers loaders and linkers via a plug-in architecture to manipulate model files, usually written in the JSON format. Using its minimalist, yet intuitive frontend, scripts of all sorts that run over the loaded models can easily be written and executed. ScriptBee offers a variety of programming languages to create the scripts in, as well highly performance due to its in-memory approach of storing the models.</p>"},{"location":"scriptbee/integration/#loader-plugin","title":"Loader Plugin","text":"<p>Honeydew can integrate with ScriptBee via its plug-in architecture as a model loader.  The plugin resides in \u201dHoneydew.ScriptBeePlugin\u201d project that has a dependency to \u201dDxWorks.ScriptBee.Plugin.Api\u201d, the nuget package used for plugins. Being a loader means parsing a json file and converting it to a dictionary of \u201dScriptBeeModel\u201d types.</p> <p>More information about the model is described in Honeydew's ScriptBee Model</p>"},{"location":"scriptbee/model/","title":"Honeydew's ScriptBee Model","text":""}]}